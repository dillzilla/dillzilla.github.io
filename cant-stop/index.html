<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Can't Stop - Pixel Edition</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        :root {
            --bg-color: #000;
            --text-color: #0FF; /* Cyan */
            --border-color: #F0F; /* Magenta */
            --highlight-color: #FF0; /* Yellow */
            --disabled-color: #555;
            --player1-color: #0F0; /* Green */
            --player2-color: #F00; /* Red */
            --player3-color: #00F; /* Blue */
            --player4-color: #FFF; /* White */
        }

        body {
            font-family: 'Press Start 2P', cursive;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            text-align: center;
            line-height: 1.6;
            font-size: 12px; /* Base for responsiveness */
        }

        h1, h2, h3 {
            color: var(--highlight-color);
            margin-bottom: 0.5em;
        }

        button {
            font-family: 'Press Start 2P', cursive;
            background-color: var(--text-color);
            color: var(--bg-color);
            border: 2px solid var(--border-color);
            padding: 10px 15px;
            margin: 5px;
            cursor: pointer;
            font-size: 1em;
            min-width: 120px;
        }

        button:hover {
            background-color: var(--highlight-color);
            color: var(--bg-color);
        }
        button:disabled {
            background-color: var(--disabled-color);
            color: #aaa;
            border-color: #777;
            cursor: not-allowed;
        }

        .screen {
            border: 3px solid var(--border-color);
            padding: 20px;
            margin-bottom: 20px;
            width: 90%;
            max-width: 600px;
            background-color: rgba(0,0,0,0.8);
        }

        #menu-screen, #rules-screen, #game-over-screen {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #rules-screen p, #rules-screen li {
            text-align: left;
            font-size: 0.9em;
        }
        #rules-screen ul {
            padding-left: 20px;
        }


        #game-screen { display: none; }
        #rules-screen { display: none; }
        #game-over-screen { display: none; }

        #player-info {
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        #board-container {
            display: flex;
            justify-content: center;
            align-items: flex-end; /* Align columns at their base */
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
            margin-bottom: 15px;
            border: 1px solid var(--border-color);
            padding: 5px;
            min-height: 200px; /* Ensure space for columns */
        }

        .column {
            display: flex;
            flex-direction: column-reverse; /* Spaces build upwards */
            align-items: center;
            margin: 0 3px; /* Reduced margin */
            padding: 3px;
            border-left: 1px solid var(--border-color);
            border-right: 1px solid var(--border-color);
            min-width: 25px; /* Ensure min width for visibility */
        }
        .column-header {
            font-size: 0.9em;
            color: var(--highlight-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 3px;
            margin-bottom: 3px;
            width: 100%;
        }
        .space {
            width: 22px; /* Slightly smaller than column */
            height: 18px; /* Slightly smaller than default line-height */
            font-size: 0.8em; /* Make marker text smaller */
            border: 1px dashed #444;
            margin: 1px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-color); /* Default space color */
        }
        .space.top-space {
            border-top: 2px solid var(--highlight-color);
        }

        /* Player markers */
        .player0 { color: var(--player1-color); }
        .player1 { color: var(--player2-color); }
        .player2 { color: var(--player3-color); }
        .player3 { color: var(--player4-color); }

        .player0temp { color: var(--player1-color); opacity: 0.6; }
        .player1temp { color: var(--player2-color); opacity: 0.6; }
        .player2temp { color: var(--player3-color); opacity: 0.6; }
        .player3temp { color: var(--player4-color); opacity: 0.6; }


        #dice-area {
            margin-bottom: 15px;
            font-size: 1.5em;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .dice-label {
            font-size: 0.8em; /* Smaller label */
            margin-bottom: 5px;
        }
        .dice {
            border: 1px solid var(--text-color);
            padding: 5px 8px;
            margin: 2px 0; /* Vertical margin */
            min-width: 25px;
            width: 30px; /* Fixed width for alignment */
            text-align: center;
        }

        #pair-choices button {
            font-size: 0.9em;
            padding: 8px 10px;
            min-width: 100px;
        }

        #message-area {
            margin-top: 15px;
            min-height: 1.5em; /* Reserve space for messages */
            color: var(--highlight-color);
        }

        /* Mobile Responsiveness */
        @media (max-width: 768px) {
            body { font-size: 10px; }
            button { padding: 8px 10px; min-width: 100px;}
            .screen { padding: 15px; }
            .column { margin: 0 2px; min-width: 20px;}
            .space { width: 18px; height: 15px; font-size: 0.7em;}
        }
        @media (max-width: 480px) {
            body { font-size: 9px; }
            #board-container { padding: 2px; }
            .column { margin: 0 1px; min-width: 18px; }
            .column-header { font-size: 0.8em; }
            .space { width: 15px; height: 13px; font-size: 0.6em; }
            button { padding: 6px 8px; min-width: 80px; margin: 3px;}
            #dice-area { font-size: 1.2em; }
            .dice { padding: 3px 5px; width: 25px; }
        }
    </style>
</head>
<body>

    <div id="menu-screen" class="screen">
        <h1>CAN'T STOP</h1>
        <h2>(Pixel Edition)</h2>
        <p>Select number of players:</p>
        <button onclick="startGame(2)">2 Players</button>
        <button onclick="startGame(3)">3 Players</button>
        <button onclick="startGame(4)">4 Players</button>
        <button onclick="showRules()">View Rules</button>
    </div>

    <div id="rules-screen" class="screen">
        <h2>RULES</h2>
        <p>Objective: Be the first to claim 3 columns.</p>
        <ul>
            <li>On your turn, roll 4 dice.</li>
            <li>Pair them into two sums (e.g., 1+2=3, 4+5=9).</li>
            <li>Choose one or two sums to advance your temporary markers (climbers) on the board columns. You can use max 3 climbers per turn.</li>
            <li>After advancing, EITHER:</li>
            <li>    A) STOP: Your climbers become permanent markers. Your turn ends.</li>
            <li>    B) ROLL AGAIN: You MUST be able to advance at least one of your current climbers with the new dice sums. If not, you BUST!</li>
            <li>BUST: Lose all progress made THIS TURN. Your turn ends.</li>
            <li>Columns 2-12 have different lengths. Claim a column by reaching its top space.</li>
        </ul>
        <button onclick="hideRules()">Back to Menu</button>
    </div>

    <div id="game-screen" class="screen">
        <div id="player-info">Player X's Turn</div>
        <div id="board-container"></div>
        <div id="dice-area">
            <div class="dice-label">Dice:</div>
            <span class="dice">?</span>
            <span class="dice">?</span>
            <span class="dice">?</span>
            <span class="dice">?</span>
        </div>
        <div id="actions-area">
            <button id="roll-dice-btn" onclick="handleRollDice()">Roll Dice</button>
            <div id="pair-choices"></div>
            <button id="stop-turn-btn" onclick="handleStopTurn()" disabled>Stop Turn</button>
        </div>
        <div id="message-area"></div>
    </div>

    <div id="game-over-screen" class="screen">
        <h2>GAME OVER!</h2>
        <p id="winner-message"></p>
        <button onclick="showMenu()">Play Again</button>
    </div>

    <script>
        const COLUMN_DEFINITIONS = {
            2: { len: 3 }, 3: { len: 5 }, 4: { len: 7 }, 5: { len: 9 },
            6: { len: 11 }, 7: { len: 13 }, 8: { len: 11 }, 9: { len: 9 },
            10: { len: 7 }, 11: { len: 5 }, 12: { len: 3 }
        };
        const PLAYER_SYMBOLS = ['P1', 'P2', 'P3', 'P4'];
        const PLAYER_CLASSES = ['player0', 'player1', 'player2', 'player3'];
        const TEMP_MARKER_SUFFIX = 't';

        let numPlayers;
        let currentPlayerIndex;
        let playersData; 
        let boardState; 
        
        let currentDice = [0,0,0,0];
        let currentRunners = []; 
        let tempRunnerPositions = {}; 

        const menuScreen = document.getElementById('menu-screen');
        const rulesScreen = document.getElementById('rules-screen');
        const gameScreen = document.getElementById('game-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const playerInfoDiv = document.getElementById('player-info');
        const boardContainer = document.getElementById('board-container');
        const diceArea = document.getElementById('dice-area');
        const rollDiceBtn = document.getElementById('roll-dice-btn');
        const stopTurnBtn = document.getElementById('stop-turn-btn');
        const pairChoicesDiv = document.getElementById('pair-choices');
        const messageArea = document.getElementById('message-area');
        const winnerMessage = document.getElementById('winner-message');

        function showScreen(screenToShow) {
            [menuScreen, rulesScreen, gameScreen, gameOverScreen].forEach(s => s.style.display = 'none');
            screenToShow.style.display = 'flex';
        }
        function showMenu() { showScreen(menuScreen); }
        function showRules() { showScreen(rulesScreen); }
        function hideRules() { showScreen(menuScreen); }

        function initBoard() {
            boardState = {};
            boardContainer.innerHTML = '';
            for (const colNumStr in COLUMN_DEFINITIONS) {
                const colNum = parseInt(colNumStr);
                boardState[colNum] = {
                    claimedBy: null,
                    spaces: Array(COLUMN_DEFINITIONS[colNum].len).fill('')
                };

                const columnDiv = document.createElement('div');
                columnDiv.classList.add('column');
                columnDiv.dataset.column = colNum;
                
                const headerDiv = document.createElement('div');
                headerDiv.classList.add('column-header');
                headerDiv.textContent = colNum;
                columnDiv.appendChild(headerDiv);

                for (let i = 0; i < COLUMN_DEFINITIONS[colNum].len; i++) {
                    const spaceDiv = document.createElement('div');
                    spaceDiv.classList.add('space');
                    if (i === COLUMN_DEFINITIONS[colNum].len - 1) {
                        spaceDiv.classList.add('top-space');
                    }
                    spaceDiv.id = `space-${colNum}-${i}`;
                    columnDiv.appendChild(spaceDiv);
                }
                boardContainer.appendChild(columnDiv);
            }
        }

        function renderBoard() {
            document.querySelectorAll('.space').forEach(s => {
                s.textContent = '';
                let baseClass = 'space';
                const parts = s.id.split('-');
                const colNum = parseInt(parts[1]);
                const spaceIndex = parseInt(parts[2]);
                if (spaceIndex === COLUMN_DEFINITIONS[colNum].len - 1) {
                    baseClass += ' top-space';
                }
                s.className = baseClass;
            });

            playersData.forEach((player, pIdx) => {
                for (const colNum in player.progress) {
                    const pos = player.progress[colNum];
                    if (pos > 0) {
                        const spaceId = `space-${colNum}-${pos-1}`;
                        const spaceDiv = document.getElementById(spaceId);
                        if (spaceDiv) {
                            spaceDiv.textContent = player.symbol;
                            spaceDiv.classList.add(player.class);
                        }
                    }
                }
            });

            for (const colNumStr in tempRunnerPositions) {
                const pos = tempRunnerPositions[colNumStr];
                if (pos > 0) {
                    const spaceId = `space-${colNumStr}-${pos-1}`;
                    const spaceDiv = document.getElementById(spaceId);
                    if (spaceDiv) {
                        spaceDiv.textContent = playersData[currentPlayerIndex].symbol + TEMP_MARKER_SUFFIX;
                        spaceDiv.classList.add(playersData[currentPlayerIndex].class + 'temp');
                    }
                }
            }
        }
        
        function startGame(playersCount) {
            numPlayers = playersCount;
            currentPlayerIndex = 0;
            playersData = [];
            for (let i = 0; i < numPlayers; i++) {
                playersData.push({
                    symbol: PLAYER_SYMBOLS[i],
                    class: PLAYER_CLASSES[i],
                    progress: {}, 
                    claimedColumns: []
                });
            }
            initBoard();
            renderBoard();
            startTurn();
            showScreen(gameScreen);
        }

        function startTurn() {
            playerInfoDiv.textContent = `${playersData[currentPlayerIndex].symbol}'s Turn`;
            playerInfoDiv.className = playersData[currentPlayerIndex].class;
            currentRunners = [];
            tempRunnerPositions = {};
            currentDice = [0,0,0,0];
            updateDiceDisplay();
            rollDiceBtn.disabled = false;
            stopTurnBtn.disabled = true;
            pairChoicesDiv.innerHTML = '';
            messageArea.textContent = 'Roll the dice!';
            renderBoard();
        }

        function rollDie() { return Math.floor(Math.random() * 6) + 1; }

        function updateDiceDisplay() {
            const diceSpans = diceArea.querySelectorAll('.dice');
            currentDice.forEach((val, i) => {
                diceSpans[i].textContent = val === 0 ? '?' : val;
            });
        }
        
        function getPossiblePairs(dice) {
            const d = [...dice];
            const pairs = new Set();
            pairs.add(JSON.stringify([d[0]+d[1], d[2]+d[3]].sort((a,b)=>a-b)));
            pairs.add(JSON.stringify([d[0]+d[2], d[1]+d[3]].sort((a,b)=>a-b)));
            pairs.add(JSON.stringify([d[0]+d[3], d[1]+d[2]].sort((a,b)=>a-b)));
            
            const result = [];
            pairs.forEach(pStr => {
                const pair = JSON.parse(pStr);
                if (pair.every(sum => sum >=2 && sum <= 12)) {
                    result.push(pair);
                }
            });
            return result;
        }

        function isColumnPlayable(colNum) {
            const colNumStr = colNum.toString();
            if (!COLUMN_DEFINITIONS[colNumStr]) return false;
            return boardState[colNumStr].claimedBy === null || boardState[colNumStr].claimedBy === currentPlayerIndex;
        }

        function handleRollDice() {
            currentDice = [rollDie(), rollDie(), rollDie(), rollDie()];
            updateDiceDisplay();
            rollDiceBtn.disabled = true;
            stopTurnBtn.disabled = true; // Disabled until a choice is made or confirmed possible
            
            let possibleDicePairs = getPossiblePairs(currentDice);
            
            if (possibleDicePairs.length === 0) { 
                messageArea.textContent = "BUST! Dice roll produced no valid sums (e.g. <2 or >12).";
                pairChoicesDiv.innerHTML = '<button id="bust-next-turn-btn" onclick="nextTurnAfterBust()">Acknowledge Bust & Next Turn</button>';
                return;
            }
            
            displayPairChoices(possibleDicePairs);
            
            // If choices are available AND runners are already on board from this turn, player can choose to stop.
            if (pairChoicesDiv.children.length > 0 && currentRunners.length > 0) {
                stopTurnBtn.disabled = false;
            }
        }

        function displayPairChoices(advancements) {
            pairChoicesDiv.innerHTML = '';
            let atLeastOneButtonGenerated = false;
            messageArea.textContent = "Choose a dice pair to advance:";

            advancements.forEach(pair => {
                const s1 = pair[0];
                const s2 = pair[1];

                let s1_can_action = false; // Can s1 be advanced or started?
                let s1_starts_new_runner = false;
                if (isColumnPlayable(s1) && (!tempRunnerPositions[s1] || tempRunnerPositions[s1] < COLUMN_DEFINITIONS[s1].len)) {
                    if (currentRunners.includes(s1.toString())) {
                        s1_can_action = true;
                    } else if (currentRunners.length < 3) {
                        s1_can_action = true;
                        s1_starts_new_runner = true;
                    }
                }

                let s2_can_action = false; // Can s2 be advanced or started?
                let s2_starts_new_runner = false;
                let runnersActiveIfS1UsedNewSlot = currentRunners.length + (s1_starts_new_runner ? 1 : 0);
                
                if (isColumnPlayable(s2) && (!tempRunnerPositions[s2] || tempRunnerPositions[s2] < COLUMN_DEFINITIONS[s2].len)) {
                    if (currentRunners.includes(s2.toString())) {
                        s2_can_action = true;
                    } else if (s1 === s2 && s1_can_action) { // s2 is advancing the same runner s1 moved/placed
                        s2_can_action = true; // Not starting a "new" runner, but actioning the one for s1
                    } else if (s1 !== s2 && runnersActiveIfS1UsedNewSlot < 3) { // s2 is a new, distinct runner
                        s2_can_action = true;
                        s2_starts_new_runner = true;
                    }
                    // Case: s1 === s2, s1 could not action (e.g. s1_starts_new_runner=false because 3 runners already out).
                    // Then s2, as a new runner (because s1 wasn't new), can start if runnersActiveIfS1UsedNewSlot < 3.
                    // This situation is simpler: currentRunners.length < 3 is the primary check for starting new.
                    else if (s1 === s2 && !s1_starts_new_runner && currentRunners.length < 3 && !currentRunners.includes(s1.toString())) {
                         // if s1 couldn't start a new runner (e.g. it was advancing existing),
                         // but s2 (same column) is now considered to start fresh.
                         // This is more like: can s1 OR s2 start a new runner on this column if it's not active.
                         // The current logic for s1_starts_new_runner should handle this for column s1.
                         // If s1=s2, and s1 is not an existing runner, s1_starts_new_runner applies to both.
                    }
                }


                let showButtonForThisPair = false;
                if (s1_can_action || s2_can_action) {
                    if (currentRunners.length > 0) { // Must advance an existing runner
                        if ((s1_can_action && currentRunners.includes(s1.toString())) ||
                            (s2_can_action && currentRunners.includes(s2.toString()))) {
                            showButtonForThisPair = true;
                        }
                    } else { // No runners out, any valid start is fine
                        showButtonForThisPair = true;
                    }
                }
                
                if (showButtonForThisPair) {
                    const btn = document.createElement('button');
                    let btnText = `${s1} & ${s2}`;
                    if (s1 === s2) btnText = `${s1} (double)`;
                    btn.textContent = `Use ${btnText}`;
                    btn.onclick = () => selectPairToAdvance(s1, s2);
                    pairChoicesDiv.appendChild(btn);
                    atLeastOneButtonGenerated = true;
                }
            });

            if (!atLeastOneButtonGenerated) {
                messageArea.textContent = (currentRunners.length > 0) ?
                    "BUST! No dice pair can advance your current runners." :
                    "BUST! No dice pair can start or advance a valid runner.";
                rollDiceBtn.disabled = true;
                stopTurnBtn.disabled = true;
                pairChoicesDiv.innerHTML = '<button id="bust-next-turn-btn" onclick="nextTurnAfterBust()">Acknowledge Bust & Next Turn</button>';
            } else {
                // If buttons are generated, player can stop if they already have runners from this turn
                if (currentRunners.length > 0) stopTurnBtn.disabled = false;
            }
        }

        function selectPairToAdvance(sum1, sum2) {
            pairChoicesDiv.innerHTML = ''; 
            let advancedAtLeastOneRunnerThisSelection = false;

            const tryAdvanceOrPlace = (sum) => {
                if (!isColumnPlayable(sum)) return false;
                const sumStr = sum.toString();
                if (tempRunnerPositions[sumStr] && tempRunnerPositions[sumStr] >= COLUMN_DEFINITIONS[sumStr].len) return false;

                if (currentRunners.includes(sumStr)) {
                    tempRunnerPositions[sumStr]++;
                    advancedAtLeastOneRunnerThisSelection = true;
                    return true;
                } else if (currentRunners.length < 3) {
                    currentRunners.push(sumStr);
                    tempRunnerPositions[sumStr] = (playersData[currentPlayerIndex].progress[sumStr] || 0) + 1;
                    advancedAtLeastOneRunnerThisSelection = true;
                    return true;
                }
                return false;
            };

            const didAdvanceSum1 = tryAdvanceOrPlace(sum1);
            if (sum1 === sum2) {
                if (didAdvanceSum1) tryAdvanceOrPlace(sum2); 
            } else {
                tryAdvanceOrPlace(sum2);
            }

            if (!advancedAtLeastOneRunnerThisSelection) {
                messageArea.textContent = "Error: Selected pair resulted in no actual advancement. BUST!";
                rollDiceBtn.disabled = true;
                stopTurnBtn.disabled = true;
                pairChoicesDiv.innerHTML = '<button id="bust-next-turn-btn" onclick="nextTurnAfterBust()">Acknowledge Bust & Next Turn</button>';
                return; 
            }
            
            renderBoard();
            rollDiceBtn.disabled = false; 
            stopTurnBtn.disabled = false; // Now that a move is made, can always stop.
            messageArea.textContent = "Roll again or Stop.";
        }

        function handleStopTurn() {
            for (const colNumStr in tempRunnerPositions) {
                const colNum = parseInt(colNumStr);
                const pos = tempRunnerPositions[colNumStr];
                playersData[currentPlayerIndex].progress[colNumStr] = pos;

                if (pos === COLUMN_DEFINITIONS[colNumStr].len && (boardState[colNumStr].claimedBy === null || boardState[colNumStr].claimedBy === currentPlayerIndex )) {
                     if(boardState[colNumStr].claimedBy === null) { // Only add to claimed if not already claimed by self
                        boardState[colNumStr].claimedBy = currentPlayerIndex;
                        playersData[currentPlayerIndex].claimedColumns.push(colNum);
                        messageArea.textContent = `${playersData[currentPlayerIndex].symbol} claimed column ${colNum}!`;
                     }
                }
            }
            
            renderBoard(); 

            if (playersData[currentPlayerIndex].claimedColumns.length >= 3) {
                gameOver();
                return;
            }
            nextTurn();
        }
        
        function nextTurnAfterBust() {
            tempRunnerPositions = {}; 
            currentRunners = [];      
            renderBoard(); 
            nextTurn();
        }

        function nextTurn() {
            currentPlayerIndex = (currentPlayerIndex + 1) % numPlayers;
            startTurn();
        }

        function gameOver() {
            winnerMessage.textContent = `${playersData[currentPlayerIndex].symbol} WINS!`;
            showScreen(gameOverScreen);
        }

        showMenu();
    </script>
</body>
</html>